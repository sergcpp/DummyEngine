#include "SceneManager.h"

#include <fstream>

#include <glslang/Include/glslang_c_interface.h>
#include <glslang/Public/resource_limits_c.h>

#include "../Renderer/Renderer_GL_Defines.inl"

#define _AS_STR(x) #x
#define AS_STR(x) _AS_STR(x)

void SceneManager::InlineShaderConstants(assets_context_t &ctx, std::string &line) {
    static std::once_flag constants_initialized;
    static Ren::HashMap32<std::string, std::string> shader_constants;
    std::call_once(constants_initialized, [&]() {
        shader_constants.Insert("$ModifyWarning", "/***********************************************/\r\n"
                                                  "/* This file was autogenerated, do not modify! */\r\n"
                                                  "/***********************************************/");

        // Uniform block locations
        shader_constants.Insert("$ubSharedDataLoc", AS_STR(REN_UB_SHARED_DATA_LOC));
        shader_constants.Insert("$ubUnifParamLoc", AS_STR(REN_UB_UNIF_PARAM_LOC));

        // Shadow properties
        if (strcmp(ctx.platform, "pc") == 0) {
            shader_constants.Insert("$ShadRes", AS_STR(REN_SHAD_RES_PC));
        } else if (strcmp(ctx.platform, "android") == 0) {
            shader_constants.Insert("$ShadRes", AS_STR(REN_SHAD_RES_ANDROID));
        } else {
            ctx.log->Error("Unknown platform %s", ctx.platform);
            return;
        }
    });

    size_t n = 0;
    while ((n = line.find('$', n)) != std::string::npos) {
        size_t l = 1;

        const char punctuation_chars[] = ".,(); $*[]\r\n";
        while (std::find(std::begin(punctuation_chars), std::end(punctuation_chars), line[n + l]) ==
               std::end(punctuation_chars)) {
            l++;
        }

        const std::string var = line.substr(n, l);

        const std::string *it = shader_constants.Find(var);
        if (it) {
            line.replace(n, l, *it);
        } else {
            ctx.log->Error("Unknown variable %s", var.c_str());
            throw std::runtime_error("Unknown variable!");
        }
    }

    if (line.find("DEF_CONST_INT(") == 0) {
        line = line.substr(14);
        const size_t n1 = line.find(',');
        if (n1 != std::string::npos) {
            const std::string binding_name = line.substr(0, n1);

            line = line.substr(n1 + 1);
            while (!line.empty() && line[0] == ' ') {
                line = line.substr(1);
            }

            const size_t n2 = line.find(')');
            if (n2 != std::string::npos) {
                const std::string binding_index = line.substr(0, n2);

                line = "#define ";
                line += binding_name;
                line += " ";
                line += binding_index;
            }
        }
    }
}

bool SceneManager::ResolveIncludes(assets_context_t &ctx, const char *in_file, std::ostream &dst_stream,
                                   Ren::SmallVectorImpl<std::string> &out_dependencies) {
    std::ifstream src_stream(in_file, std::ios::binary);
    if (!src_stream) {
        ctx.log->Error("Failed to open %s", in_file);
        return false;
    }

    int line_counter = 0;

    std::string line;
    while (std::getline(src_stream, line)) {
        if (!line.empty() && line.back() == '\r') {
            line = line.substr(0, line.size() - 1);
        }

        if (line.rfind("#include ") == 0) {
            const size_t n1 = line.find_first_of('\"');
            const size_t n2 = line.find_last_of('\"');

            const std::string file_name = line.substr(n1 + 1, n2 - n1 - 1);

            const auto slash_pos = size_t(intptr_t(strrchr(in_file, '/') - in_file));
            const std::string full_path = std::string(in_file, slash_pos + 1) + file_name;

            dst_stream << "#line 0\r\n";

            auto it = std::find(std::begin(out_dependencies), std::end(out_dependencies), full_path);
            if (it == std::end(out_dependencies)) {
                out_dependencies.emplace_back(full_path);
            }

            if (!ResolveIncludes(ctx, full_path.c_str(), dst_stream, out_dependencies)) {
                return false;
            }

            dst_stream << "\r\n#line " << line_counter << "\r\n";
        } else {
            InlineShaderConstants(ctx, line);

            dst_stream << line << "\r\n";
        }
    }

    return true;
}

bool SceneManager::HPreprocessShader(assets_context_t &ctx, const char *in_file, const char *out_file,
                                     Ren::SmallVectorImpl<std::string> &out_dependencies) {
    std::remove(out_file);

    std::vector<std::string> permutations;
    permutations.emplace_back();

    { // resolve includes, inline constants
        std::ifstream src_stream(in_file, std::ios::binary);
        if (!src_stream) {
            return false;
        }
        std::ofstream dst_stream(out_file, std::ios::binary);
        std::string line;

        int line_counter = 0;

        while (std::getline(src_stream, line)) {
            /*if (!line.empty() && line.back() == '\r') {
                line = line.substr(0, line.size() - 1);
            }*/

            if (line.rfind("#version ") == 0) {
                if (strcmp(ctx.platform, "pc") == 0 && line.rfind("es") != std::string::npos) {
                    line = "#version 430";
                }
                dst_stream << line << "\r\n";
            } else if (line.rfind("#include ") == 0) {
                const size_t n1 = line.find_first_of('\"');
                const size_t n2 = line.find_last_of('\"');

                const std::string file_name = line.substr(n1 + 1, n2 - n1 - 1);

                const auto slash_pos = size_t(intptr_t(strrchr(in_file, '/') - in_file));
                const std::string full_path = std::string(in_file, slash_pos + 1) + file_name;

                dst_stream << "#line 0\r\n";

                auto it = std::find(std::begin(out_dependencies), std::end(out_dependencies), full_path);
                if (it == std::end(out_dependencies)) {
                    out_dependencies.emplace_back(full_path);
                }

                if (!ResolveIncludes(ctx, full_path.c_str(), dst_stream, out_dependencies)) {
                    ctx.log->Error("Failed to preprocess %s", full_path.c_str());
                    return false;
                }

                dst_stream << "\r\n#line " << (line_counter + 2) << "\r\n";
            } else if (line.find("PERM ") == 0) { // NOLINT
                dst_stream << line << "\r\n";
                permutations.emplace_back(line.substr(5));
                if (permutations.back().back() == '\r') {
                    permutations.back().pop_back();
                }
            } else {
                InlineShaderConstants(ctx, line);

                if (!line.empty() && line.back() == '\r') {
                    line.pop_back();
                }
                dst_stream << line << "\r\n";
            }

            ++line_counter;
        }
    }

    if (strcmp(ctx.platform, "pc") == 0) {
        for (const bool is_vk : {false, true}) {
            const bool use_spv14 = (strstr(in_file, ".rgen") || strstr(in_file, ".rint") || strstr(in_file, ".rahit") ||
                                    strstr(in_file, ".rchit") || strstr(in_file, ".rmiss") ||
                                    strstr(in_file, ".rcall") || strstr(in_file, "spirv14"));
            if (!is_vk && use_spv14) {
                continue;
            }
            for (const std::string &perm : permutations) {
                std::string spv_file = out_file + perm;

                { // replace extension
                    const size_t n = spv_file.rfind(".glsl");
                    assert(n != std::string::npos);
                    if (is_vk) {
                        spv_file.replace(n + 1, 4, "spv");
                    } else {
                        spv_file.replace(n + 1, 4, "spv_ogl");
                    }
                }

                ctx.log->Info("[PrepareAssets] Prep %s", spv_file.c_str());
                std::remove(spv_file.c_str());

                std::string preamble;
                if (!perm.empty()) {
                    const char *params = perm.c_str();
                    if (!params || params[0] != '@') {
                        continue;
                    }

                    int count = 0;

                    const char *p1 = params + 1;
                    const char *p2 = p1 + 1;
                    while (*p2) {
                        if (*p2 == '=') {
                            preamble += "#define ";
                            preamble += std::string(p1, p2);

                            p1 = p2 + 1;
                            while (p2 && *p2 && *p2 != ';') {
                                ++p2;
                            }

                            preamble += std::string(p1, p2);
                            preamble += "\n";

                            if (*p2) {
                                p1 = ++p2;
                            }
                            ++count;
                        } else if (*p2 == ';') {
                            preamble += "#define ";
                            preamble += std::string(p1, p2);
                            preamble += "\n";

                            p1 = ++p2;
                            ++count;
                        }

                        if (*p2) {
                            ++p2;
                        }
                    }

                    if (p1 != p2) {
                        preamble += "#define ";
                        preamble += std::string(p1, p2);
                        preamble += "\n";

                        ++count;
                    }
                }

                glslang_input_t glslang_input = {};
                glslang_input.language = GLSLANG_SOURCE_GLSL;
                glslang_input.target_language = GLSLANG_TARGET_SPV;
                glslang_input.default_version = 100;
                glslang_input.default_profile = GLSLANG_NO_PROFILE;
                glslang_input.force_default_version_and_profile = false;
                glslang_input.forward_compatible = false;
                glslang_input.messages = GLSLANG_MSG_DEFAULT_BIT;
                glslang_input.resource = glslang_default_resource();

                std::ifstream glsl_file(out_file, std::ios::binary | std::ios::ate);
                const size_t glsl_file_size = size_t(glsl_file.tellg());
                glsl_file.seekg(0, std::ios::beg);

                std::unique_ptr<char[]> glsl_file_data(new char[glsl_file_size + 1]);
                glsl_file.read(glsl_file_data.get(), glsl_file_size);
                glsl_file_data[glsl_file_size] = 0;

                if (strstr(out_file, ".vert.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_VERTEX;
                } else if (strstr(out_file, ".frag.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_FRAGMENT;
                } else if (strstr(out_file, ".comp.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_COMPUTE;
                } else if (strstr(out_file, ".geom.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_GEOMETRY;
                } else if (strstr(out_file, ".tesc.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_TESSCONTROL;
                } else if (strstr(out_file, ".tese.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_TESSEVALUATION;
                } else if (strstr(out_file, ".rgen.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_RAYGEN;
                } else if (strstr(out_file, ".rchit.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_CLOSESTHIT;
                } else if (strstr(out_file, ".rahit.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_ANYHIT;
                } else if (strstr(out_file, ".rmiss.glsl")) {
                    glslang_input.stage = GLSLANG_STAGE_MISS;
                }

                glslang_input.code = glsl_file_data.get();

                if (is_vk) {
                    glslang_input.client = GLSLANG_CLIENT_VULKAN;
                    glslang_input.client_version = GLSLANG_TARGET_VULKAN_1_1;
                    if (use_spv14) {
                        glslang_input.target_language_version = GLSLANG_TARGET_SPV_1_4;
                    } else {
                        glslang_input.target_language_version = GLSLANG_TARGET_SPV_1_3;
                    }
                } else {
                    glslang_input.client = GLSLANG_CLIENT_OPENGL;
                    glslang_input.client_version = GLSLANG_TARGET_OPENGL_450;
                    glslang_input.target_language_version = GLSLANG_TARGET_SPV_1_3;
                }

                glslang_shader_t *shader = glslang_shader_create(&glslang_input);

                if (!preamble.empty()) {
                    glslang_shader_set_preamble(shader, preamble.c_str());
                }

                if (!glslang_shader_preprocess(shader, &glslang_input)) {
                    ctx.log->Error("[PrepareAssets] GLSL preprocessing failed %s", out_file);

                    ctx.log->Error("%s", glslang_shader_get_info_log(shader));
                    ctx.log->Error("%s", glslang_shader_get_info_debug_log(shader));
                    ctx.log->Error("%s", glslang_input.code);

#if !defined(NDEBUG) && defined(_WIN32)
                    __debugbreak();
#endif

                    glslang_shader_delete(shader);
                    return false;
                }

                if (!glslang_shader_parse(shader, &glslang_input)) {
                    ctx.log->Error("[PrepareAssets] GLSL parsing failed %s", out_file);
                    ctx.log->Error("%s", glslang_shader_get_info_log(shader));
                    ctx.log->Error("%s", glslang_shader_get_info_debug_log(shader));
                    // ctx.log->Error("%s", glslang_shader_get_preprocessed_code(shader));

#if !defined(NDEBUG) && defined(_WIN32)
                    __debugbreak();
#endif

                    glslang_shader_delete(shader);
                    return false;
                }

                glslang_program_t *program = glslang_program_create();
                glslang_program_add_shader(program, shader);

                int msg_rules = GLSLANG_MSG_SPV_RULES_BIT;
                if (is_vk) {
                    msg_rules |= GLSLANG_MSG_VULKAN_RULES_BIT;
                }
                if (!glslang_program_link(program, msg_rules)) {
                    ctx.log->Error("GLSL linking failed %s\n", out_file);
                    ctx.log->Error("%s\n", glslang_program_get_info_log(program));
                    ctx.log->Error("%s\n", glslang_program_get_info_debug_log(program));

#if !defined(NDEBUG) && defined(_WIN32)
                    __debugbreak();
#endif

                    glslang_program_delete(program);
                    glslang_shader_delete(shader);
                    return false;
                }

                glslang_program_SPIRV_generate(program, glslang_input.stage);

                std::vector<uint32_t> out_shader_module(glslang_program_SPIRV_get_size(program));
                glslang_program_SPIRV_get(program, out_shader_module.data());

                { // write output file
                    std::ofstream out_spv_file(spv_file, std::ios::binary);
                    out_spv_file.write((char *)out_shader_module.data(), out_shader_module.size() * sizeof(uint32_t));
                }

                // const char *spirv_messages = glslang_program_SPIRV_get_messages(program);
                // if (spirv_messages) {
                //     ctx.log->Info("(%s) %s\b", out_file, spirv_messages);
                // }

                glslang_program_delete(program);
                glslang_shader_delete(shader);
            }
        }
    }

    return true;
}

#undef AS_STR
#undef _AS_STR
