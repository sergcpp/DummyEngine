#include "SceneManager.h"

#include <fstream>

#include "../Renderer/Renderer_GL_Defines.inl"

void SceneManager::InlineShaderConstants(assets_context_t &ctx, std::string &line) {
    static bool constants_initialized = false;
    static Ren::HashMap32<std::string, std::string> shader_constants;
    if (!constants_initialized) {
        shader_constants.Insert("$ModifyWarning", "/***********************************************/\r\n"
                                                  "/* This file was autogenerated, do not modify! */\r\n"
                                                  "/***********************************************/");

        // Uniform block locations
        shader_constants.Insert("$ubSharedDataLoc", AS_STR(REN_UB_SHARED_DATA_LOC));
        shader_constants.Insert("$ubUnifParamLoc", AS_STR(REN_UB_UNIF_PARAM_LOC));

        // Shadow properties
        if (strcmp(ctx.platform, "pc") == 0) {
            shader_constants.Insert("$ShadRes", AS_STR(REN_SHAD_RES_PC));
        } else if (strcmp(ctx.platform, "android") == 0) {
            shader_constants.Insert("$ShadRes", AS_STR(REN_SHAD_RES_ANDROID));
        } else {
            ctx.log->Error("Unknown platform %s", ctx.platform);
            return;
        }

        constants_initialized = true;
    }

    size_t n = 0;
    while ((n = line.find('$', n)) != std::string::npos) {
        size_t l = 1;

        const char punctuation_chars[] = ".,(); $*[]\r\n";
        while (std::find(std::begin(punctuation_chars), std::end(punctuation_chars), line[n + l]) ==
               std::end(punctuation_chars)) {
            l++;
        }

        const std::string var = line.substr(n, l);

        const std::string *it = shader_constants.Find(var);
        if (it) {
            line.replace(n, l, *it);
        } else {
            ctx.log->Error("Unknown variable %s", var.c_str());
            throw std::runtime_error("Unknown variable!");
        }
    }

    if (line.find("DEF_CONST_INT(") == 0) {
        line = line.substr(14);
        const size_t n1 = line.find(',');
        if (n1 != std::string::npos) {
            const std::string binding_name = line.substr(0, n1);

            line = line.substr(n1 + 1);
            while (!line.empty() && line[0] == ' ') {
                line = line.substr(1);
            }

            const size_t n2 = line.find(')');
            if (n2 != std::string::npos) {
                const std::string binding_index = line.substr(0, n2);

                line = "#define ";
                line += binding_name;
                line += " ";
                line += binding_index;
            }
        }
    }
}

bool SceneManager::ResolveIncludes(assets_context_t &ctx, const char *in_file, std::ostream &dst_stream,
                                   Ren::SmallVectorImpl<std::string> &out_dependencies) {
    std::ifstream src_stream(in_file, std::ios::binary);
    if (!src_stream) {
        ctx.log->Error("Failed to open %s", in_file);
        return false;
    }

    int line_counter = 0;

    std::string line;
    while (std::getline(src_stream, line)) {
        if (!line.empty() && line.back() == '\r') {
            line = line.substr(0, line.size() - 1);
        }

        if (line.rfind("#include ") == 0) {
            const size_t n1 = line.find_first_of('\"');
            const size_t n2 = line.find_last_of('\"');

            const std::string file_name = line.substr(n1 + 1, n2 - n1 - 1);

            const auto slash_pos = size_t(intptr_t(strrchr(in_file, '/') - in_file));
            const std::string full_path = std::string(in_file, slash_pos + 1) + file_name;

            dst_stream << "#line 0\r\n";

            auto it = std::find(std::begin(out_dependencies), std::end(out_dependencies), full_path);
            if (it == std::end(out_dependencies)) {
                out_dependencies.emplace_back(full_path);
            }

            if (!ResolveIncludes(ctx, full_path.c_str(), dst_stream, out_dependencies)) {
                return false;
            }

            dst_stream << "\r\n#line " << line_counter << "\r\n";
        } else {
            InlineShaderConstants(ctx, line);

            dst_stream << line << "\r\n";
        }
    }

    return true;
}

bool SceneManager::HPreprocessShader(assets_context_t &ctx, const char *in_file, const char *out_file,
                                     Ren::SmallVectorImpl<std::string> &out_dependencies) {
    std::remove(out_file);

    std::vector<std::string> permutations;
    permutations.emplace_back();

    { // resolve includes, inline constants
        std::ifstream src_stream(in_file, std::ios::binary);
        if (!src_stream) {
            return false;
        }
        std::ofstream dst_stream(out_file, std::ios::binary);
        std::string line;

        int line_counter = 0;

        while (std::getline(src_stream, line)) {
            /*if (!line.empty() && line.back() == '\r') {
                line = line.substr(0, line.size() - 1);
            }*/

            if (line.rfind("#version ") == 0) {
                if (strcmp(ctx.platform, "pc") == 0 && line.rfind("es") != std::string::npos) {
                    line = "#version 430";
                }
                dst_stream << line << "\r\n";
            } else if (line.rfind("#include ") == 0) {
                const size_t n1 = line.find_first_of('\"');
                const size_t n2 = line.find_last_of('\"');

                const std::string file_name = line.substr(n1 + 1, n2 - n1 - 1);

                const auto slash_pos = size_t(intptr_t(strrchr(in_file, '/') - in_file));
                const std::string full_path = std::string(in_file, slash_pos + 1) + file_name;

                dst_stream << "#line 0\r\n";

                auto it = std::find(std::begin(out_dependencies), std::end(out_dependencies), full_path);
                if (it == std::end(out_dependencies)) {
                    out_dependencies.emplace_back(full_path);
                }

                if (!ResolveIncludes(ctx, full_path.c_str(), dst_stream, out_dependencies)) {
                    ctx.log->Error("Failed to preprocess %s", full_path.c_str());
                    return false;
                }

                dst_stream << "\r\n#line " << (line_counter + 2) << "\r\n";
            } else if (line.find("PERM ") == 0) { // NOLINT
                dst_stream << line << "\r\n";
                permutations.emplace_back(line.substr(5));
            } else {
                InlineShaderConstants(ctx, line);

                if (line.back() == '\r') {
                    line.pop_back();
                }
                dst_stream << line << "\r\n";
            }

            ++line_counter;
        }
    }

    if (strcmp(ctx.platform, "pc") == 0) {
        for (const bool is_vk : {false, true}) {
            const bool use_spv14 = (strstr(in_file, ".rgen") || strstr(in_file, ".rint") || strstr(in_file, ".rahit") ||
                                    strstr(in_file, ".rchit") || strstr(in_file, ".rmiss") ||
                                    strstr(in_file, ".rcall") || strstr(in_file, "spirv14"));
            if (!is_vk && use_spv14) {
                continue;
            }
            for (const std::string &perm : permutations) {
                std::string spv_file = out_file + perm;

                { // replace extension
                    const size_t n = spv_file.rfind(".glsl");
                    assert(n != std::string::npos);
                    if (is_vk) {
                        spv_file.replace(n + 1, 4, "spv");
                    } else {
                        spv_file.replace(n + 1, 4, "spv_ogl");
                    }
                }

                ctx.log->Info("[PrepareAssets] Prep %s", spv_file.c_str());
                std::remove(spv_file.c_str());
#if defined(_WIN32)
                std::string compile_cmd = "src/libs/spirv/win32/glslangValidator";
#elif defined(__linux__)
                std::string compile_cmd = "src/libs/spirv/linux/glslangValidator";
#elif defined(__APPLE__)
                std::string compile_cmd = "src/libs/spirv/macos/glslangValidator";
#endif

                if (!perm.empty()) {
                    const char *params = perm.c_str();
                    if (!params || params[0] != '@') {
                        continue;
                    }

                    int count = 0;

                    const char *p1 = params + 1;
                    const char *p2 = p1 + 1;
                    while (*p2) {
                        if (*p2 == '=') {
                            compile_cmd += " -D";
                            compile_cmd += std::string(p1, p2);

                            p1 = p2 + 1;
                            while (p2 && *p2 && *p2 != ';') {
                                ++p2;
                            }

                            compile_cmd += std::string(p1, p2);

                            if (*p2) {
                                p1 = ++p2;
                            }
                            ++count;
                        } else if (*p2 == ';') {
                            compile_cmd += " -D";
                            compile_cmd += std::string(p1, p2);
                            p1 = ++p2;
                            ++count;
                        }

                        if (*p2) {
                            ++p2;
                        }
                    }

                    if (p1 != p2) {
                        compile_cmd += " -D";
                        compile_cmd += std::string(p1, p2);
                        ++count;
                    }
                }

                if (is_vk) {
                    compile_cmd += " -V ";
                    if (use_spv14) {
                        compile_cmd += " --target-env spirv1.4 ";
                    } else {
                        compile_cmd += " --target-env spirv1.3 ";
                    }
                } else {
                    compile_cmd += " -G --target-env spirv1.3 ";
                }
                compile_cmd += out_file;
                compile_cmd += " -o \"";
                compile_cmd += spv_file;
                compile_cmd += '\"';

#ifdef _WIN32
                std::replace(compile_cmd.begin(), compile_cmd.end(), '/', '\\');
#endif
                int res = system(compile_cmd.c_str());
                if (res != 0) {
                    ctx.log->Error("[PrepareAssets] Failed to compile %s", spv_file.c_str());
#if !defined(NDEBUG) && defined(_WIN32)
                    __debugbreak();
#endif
                    return false;
                }

#if defined(_WIN32)
                std::string optimize_cmd = "src/libs/spirv/win32/spirv-opt "
#elif defined(__linux__)
                std::string optimize_cmd = "src/libs/spirv/linux/spirv-opt "
#elif defined(__APPLE__)
                std::string optimize_cmd = "src/libs/spirv/macos/spirv-opt "
#endif
                                           "--preserve-bindings "
                                           "--wrap-opkill "
                                           "--eliminate-dead-branches "
                                           "--merge-return "
                                           //"--inline-entry-points-exhaustive "
                                           "--eliminate-dead-functions "
                                           "--eliminate-dead-code-aggressive "
                                           "--private-to-local "
                                           "--eliminate-local-single-block "
                                           "--eliminate-local-single-store "
                                           "--eliminate-dead-code-aggressive "
                                           "--scalar-replacement=100 "
                                           "--convert-local-access-chains "
                                           "--eliminate-local-single-block "
                                           "--eliminate-local-single-store "
                                           "--eliminate-dead-code-aggressive "
                                           //"--ssa-rewrite "
                                           "--eliminate-dead-code-aggressive "
                                           "--ccp "
                                           "--eliminate-dead-code-aggressive "
                                           "--loop-unroll "
                                           "--eliminate-dead-branches "
                                           "--redundancy-elimination "
                                           "--combine-access-chains "
                                           "--simplify-instructions "
                                           "--scalar-replacement=100 "
                                           "--convert-local-access-chains "
                                           //"--eliminate-local-single-block "
                                           "--eliminate-local-single-store "
                                           "--eliminate-dead-code-aggressive "
                                           //"--ssa-rewrite "
                                           "--eliminate-dead-code-aggressive "
                                           "--vector-dce "
                                           "--eliminate-dead-inserts "
                                           "--eliminate-dead-branches "
                                           "--simplify-instructions "
                                           "--if-conversion "
                                           "--copy-propagate-arrays "
                                           "--reduce-load-size "
                                           "--eliminate-dead-code-aggressive "
                                           "--merge-blocks "
                                           "--redundancy-elimination "
                                           "--eliminate-dead-branches "
                                           "--merge-blocks "
                                           "--simplify-instructions "
                                           "--validate-after-all ";

                optimize_cmd += '\"';
                optimize_cmd += spv_file;
                optimize_cmd += "\" -o \"";
                optimize_cmd += spv_file;
                optimize_cmd += '\"';

#ifdef _WIN32
                std::replace(optimize_cmd.begin(), optimize_cmd.end(), '/', '\\');
#endif
                res = system(optimize_cmd.c_str());
                if (res != 0) {
                    ctx.log->Error("[PrepareAssets] Failed to optimize %s", spv_file.c_str());
#if !defined(NDEBUG) && defined(_WIN32)
                    __debugbreak();
#endif
                    return false;
                }

#if 0
                std::string cross_cmd = "src/libs/spirv/spirv-cross ";
                if (strcmp(ctx.platform, "pc") == 0) {
                    cross_cmd += "--version 430 ";
                } else if (strcmp(ctx.platform, "android") == 0) {
                    cross_cmd += "--version 310 --es ";
                    cross_cmd += "--extension GL_EXT_texture_buffer ";
                }
                cross_cmd +=
                    "--no-support-nonzero-baseinstance --glsl-emit-push-constant-as-ubo ";
                cross_cmd += spv_file;
                cross_cmd += " --output ";
                cross_cmd += out_file;

#ifdef _WIN32
                std::replace(cross_cmd.begin(), cross_cmd.end(), '/', '\\');
#endif
                // res = system(cross_cmd.c_str());
                if (res != 0) {
                    ctx.log->Error("[PrepareAssets] Failed to cross-compile %s",
                                   spv_file.c_str());
#if !defined(NDEBUG) && defined(_WIN32)
                    __debugbreak();
#endif
                    return false;
                }
#endif
            }
        }
    }

    return true;
}
